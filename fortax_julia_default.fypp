#:mute

#! list for system components

#:set SYSLIST = ['inctax', 'natins', 'chben', 'fc', 'ctc', 'wtc', 'ntc', &
                 'cctaxrefund', 'incsup', 'ctax', 'rebatesys', 'hben', 'ctaxben', &
                 'ccben', 'uc', 'statepen', 'bencap', 'extra']

#! list for value labels

#:set LABLIST = ['bool', 'ctax', 'tenure', 'region', 'sex', 'famtype']

#! prevision type mapping

#:set JULIA_TYPE = {"integer": "Cint", "bool": "Cint", "double": "Cdouble"}

#! default values by type

#:set JULIA_TYPE_DEFAULT = {"integer": "0", "bool": "0", "double": "0.0"}

#! Joins stripped lines with given character string

#:def join_lines(txt, joinstr, prefix="", suffix="")
    ${prefix + joinstr.join([line.strip() for line in txt.split("\n")]) + suffix}$
#:enddef

#! Remove blank lines from given character string

#:def remove_blank_lines(txt)
${"".join([s for s in txt.strip().splitlines(True) if s.strip()])}$
#:enddef

#! Add Fortran line continuation character

#:def line_continutation(txt)
${"".join([line+", &\n" for line in txt.split("\n")])}$
#:enddef

#! Adjust indentation

#:def indent(txt)
${"".join([" "*4 + line+"\n" for line in txt.split("\n")])}$
#:enddef

#! Check that the arguments are valid

#:def check_fortax_arg(type, var, str, attr, kwargs)
    #:assert attr in ['rate', 'amount', 'minamount', 'null', 'range', 'scale', 'label']
    #:assert type in ['bool', 'integer', 'double']
    #:for kw in kwargs
        #:assert kw in ['lowerdim', 'dim', 'dimvar', 'value', 'label', 'ignore', 'fmt']
    #:endfor
#:enddef

#! Defining types

#:def fortax_type_def(name, **defkwargs)
    #:for kw in defkwargs
        #:assert kw in ['attributes', 'suffix', 'assumed']
    #:endfor
    #:if "attributes" in defkwargs
        #:set attributes = ", " + defkwargs["attributes"].strip('"')
    #:else
        #:set attributes = ""
    #:endif
    #:if "suffix" in defkwargs
        #:set suffix = defkwargs["suffix"].strip('"')
    #:else
        #:set suffix = ""
    #:endif
    #:def fortaxdef(type, var, str, attr, **kwargs)
        #:mute
            $:check_fortax_arg(type, var, str, attr, kwargs)
            #:if "value" in kwargs
                #:set default = kwargs["value"]
            #:else
                #:set default = JULIA_TYPE_DEFAULT[type]
            #:endif
            #:if "dim" in kwargs
                #:set array = True
            #:else
                #:set array = False
            #:endif
        #:endmute
        #:if array
        ${var}$::SVector{${kwargs["dim"]}$, ${JULIA_TYPE[type]}$} = @SVector [${default}$ for _ = 1:${kwargs["dim"]}$]
        #:else
        ${var}$::${JULIA_TYPE[type]}$ = ${default}$
        #:endif
    #:enddef
    #:include "include_files.fypp"
#:enddef

#! Type values

#:def fortax_type_val(name, **defkwargs)
    #:call remove_blank_lines
    #:if 'suffix' in defkwargs
    #:set sfx = defkwargs["suffix"]
    #:else
    #:set sfx = ""
    #:endif
    #:if "ignore" in defkwargs
        #:set allow_ignore = defkwargs['ignore']
    #:else
        #:set allow_ignore = False
    #:endif
    #:def fortaxdef(type, var, str, attr, **kwargs)
    #:mute
        $:check_fortax_arg(type, var, str, attr, kwargs)
        #:if allow_ignore
            #:if 'ignore' in kwargs
                #:set ignore = kwargs["ignore"]
            #:else
                #:set ignore = False
            #:endif
        #:else
            #:set ignore = False
        #:endif
    #:endmute
    #:if not ignore
        #:if 'dim' in kwargs
            #:if 'value' in kwargs
                ${var}$${sfx}$ = [${kwargs["value"]}$]
            #:else
                ${var}$${sfx}$ = [${JULIA_TYPE_DEFAULT[type]}$]
            #:endif
        #:else
            #:if 'value' in kwargs
                ${var}$${sfx}$ = ${kwargs["value"]}$
            #:else
                ${var}$${sfx}$ = ${JULIA_TYPE_DEFAULT[type]}$
            #:endif
        #:endif
    #:endif
    #:enddef
    #:include "include_files.fypp"
    #:endcall
#:enddef

#! Constant parameters

#:def fortax_const()
    #:def fortaxdef(type, var, str, attr, **kwargs)
    #:mute
    $:check_fortax_arg(type, var, str, attr, kwargs)
    #:assert 'value' in kwargs
    #:endmute
    const ${var}$ = ${kwargs["value"]}$
    #:enddef
    #:include "fortax_const.inc"
#:enddef

#! parameterised labels

#:def fortax_label_param()
    #:for LAB in LABLIST
        #:call join_lines(joinstr = ", ", prefix="const lab_" + LAB + " = (", suffix=")")
        @:fortax_type_val(lab_${LAB}$)
        #:endcall
    #:endfor
#:enddef

#! value labels
#:def fortax_value_lab(lab, labval)
lab_${lab}$.${labval}$
#:enddef

#:endmute

@:fortax_const()
@:fortax_label_param()

@with_kw struct famad_t
@:fortax_type_def(famad)
end

@with_kw struct fam_t
    @:fortax_type_def(fam)
    ad::SVector{2, famad_t} = @SVector [famad_t() for _ = 1:2]
end

@with_kw struct netad_t
    @:fortax_type_def(netad)
end

@with_kw struct nettu_t
    @:fortax_type_def(nettu)
end

@with_kw struct net_t
    ad::SVector{2, netad_t} = @SVector [netad_t() for _ = 1:2]
    tu::nettu_t = nettu_t()
end

@with_kw struct rpi_t
    ndate::Cint = 0
    date::SVector{maxRpi, Cint} = zeros(maxRpi)
    index::SVector{maxRpi, Cdouble} = ones(maxRpi)
end

@with_kw struct sysindex_t
    nsys::Cint = 0
    date0::SVector{maxSysIndex, Cint} = zeros(maxRpi)
    date1::SVector{maxSysIndex, Cint} = zeros(maxRpi)
    index::SMatrix{len_sysindex, maxSysIndex, Cchar} = ' '
end

#:for SYS in SYSLIST
@with_kw struct ${SYS}$_t
    @:fortax_type_def(${SYS}$)
end

#:endfor

@with_kw struct sys_t
    sysname::SVector{len_sysname, Cchar} = ' '
    sysdesc::SVector{len_sysdesc, Cchar} = ' '
    #:for SYS in SYSLIST
        ${SYS}$::${SYS}$_t = ${SYS}$_t()
    #:endfor
end

@with_kw struct bcout_t
    kinks_num::Cint = 0
    kinks_hrs::SVector{maxKinks, Cdouble} = 0.0
    kinks_earn::SVector{maxKinks, Cdouble} = 0.0
    kinks_net::SVector{maxKinks, Cdouble} = 0.0
    kinks_mtr::SVector{maxKinks, Cdouble} = 0.0
    bc_desc::SVector{len_bcdesc, Cchar} = ' '
end


#:def fam_gen_bounds(name, **defkwargs)
    #:if 'suffix' in defkwargs
        #:set sfx = defkwargs["suffix"]
    #:else
        #:set sfx = ""
    #:endif
    #:if "ignore" in defkwargs
        #:set allow_ignore = defkwargs['ignore']
    #:else
        #:set allow_ignore = False
    #:endif
    #:def fortaxdef(type, var, str, attr, **kwargs)
        #:if allow_ignore
            #:if 'ignore' in kwargs
                #:set ignore = kwargs["ignore"]
            #:else
                #:set ignore = False
            #:endif
        #:else
            #:set ignore = False
        #:endif
        #:if not ignore
            #:if 'dim' in kwargs
                #:set dim = kwargs["dim"]
                thislen = length(${var}$)
                if thislen > ${dim}$
                    fortaxError("${var}$ exceeds bounds in fam_gam")
                elseif thislen < ${dim}$
                    resize!(${var}$${sfx}$, ${dim}$)
                    #:if 'value' in kwargs
                        ${var}$${sfx}$[thislen+1:${dim}$] .= ${kwargs["value"]}$
                    #:else
                        ${var}$${sfx}$[thislen+1:${dim}$] .= ${JULIA_TYPE_DEFAULT[type]}$
                    #:endif
                    #:if 'dimvar' in kwargs
                        ${kwargs["dimvar"]}$ = max(${kwargs["dimvar"]}$, thislen)
                    #:endif
                end
            #:endif
        #:endif
    #:enddef
    #:include "include_files.fypp"
#:enddef

#:def fortax_type_list(name, **defkwargs)
    #:call remove_blank_lines
    #:for kw in defkwargs
        #:assert kw in ['suffix', 'ignore']
    #:endfor
    #:if "suffix" in defkwargs
        #:set suffix = defkwargs["suffix"].strip('"')
    #:else
        #:set suffix = ""
    #:endif
    #:if "ignore" in defkwargs
        #:set allow_ignore = defkwargs['ignore']
    #:else
        #:set allow_ignore = False
    #:endif
    #:def fortaxdef(type, var, str, attr, **kwargs)
        #:mute
            $:check_fortax_arg(type, var, str, attr, kwargs)
            #:if allow_ignore
                #:if 'ignore' in kwargs
                    #:set ignore = kwargs["ignore"]
                #:else
                    #:set ignore = False
                #:endif
            #:else
                #:set ignore = False
            #:endif
        #:endmute
        #:if not ignore
        ${var}$${suffix}$
        #:endif
    #:enddef
    #:include "include_files.fypp"
    #:endcall
#:enddef

#:def fortax_fam_gen()
    #:call join_lines(joinstr = ", ", prefix="function fam_gen(;", suffix=")")
    @:fortax_type_val(fam, ignore = True)
    @:fortax_type_val(famad, suffix = 1, ignore = True)
    @:fortax_type_list(famad, suffix = "2 = nothing", ignore = True)
    #:endcall

    #:call join_lines(joinstr = ") && isnothing(", prefix="isnothing(", suffix=") ? (ad2 = false) : (ad2 = true)")
        @:fortax_type_list(famad, suffix = 2)
    #:endcall

    #:set name = "famad"
    #:def fortaxdef(type, var, str, attr, **kwargs)
        #:if "value" in kwargs
        isnothing(${var}$2) && (${var}$2 = ${kwargs["value"]}$)
        #:else
        isnothing(${var}$2) && (${var}$2 = ${JULIA_TYPE_DEFAULT[type]}$)
        #:endif
    #:enddef
    #:include "include_files.fypp"

    #:call join_lines(joinstr = ", ", prefix="famad1 = famad_t(", suffix=")")
        @:fortax_type_list(famad, suffix = 1)
    #:endcall
    #:call join_lines(joinstr = ", ", prefix="famad2 = famad_t(", suffix=")")
        @:fortax_type_list(famad, suffix = 2)
    #:endcall

    @:fam_gen_bounds(fam, ignore = True)
    @:fam_gen_bounds(famad, suffix = 1, ignore = True)
    @:fam_gen_bounds(famad, suffix = 2, ignore = True)

    ad2 && (couple = 1)

    # equivalent to behaviour fam_refresh

    nkids = min(max(nkids, 0), maxKids)
    kidage[1:nkids] = min.(max.(kidage[1:nkids], 0), 18)
    age1 = min(max(age1, 16), 200)
    age2 = min(max(age2, 16), 200)

    married == 1 && (couple = 1)

    kidagedist0 = zeros(Int32, 21)
    kidagedist1 = zeros(Int32, 21)
    if (nkids > 0)
        for i = 1:nkids
            if (kidsex[i] == 0)
                kidagedist0[2+kidage[i]] = kidagedist0[2+kidage[i]] + 1
            else
                kidagedist1[2+kidage[i]] = kidagedist1[2+kidage[i]] + 1
            end
        end
        kidagedist0 = cumsum(kidagedist0)
        kidagedist1 = cumsum(kidagedist1)
        kidagedist = kidagedist0 + kidagedist1
        yngkid = minimum(kidage[1:nkids])
    else
        kidagedist = zeros(Int32, 21)
        yngkid = -1
    end

    # familty type
    if (couple == 0)
        if (nkids == 0)
            famtype = lab_famtype.single_nokids
        else
            famtype = lab_famtype.single_kids
        end
    else
        if (nkids == 0)
            famtype = lab_famtype.couple_nokids
        else
            famtype = lab_famtype.couple_kids
        end
    end

    #:call join_lines(joinstr = ", ", prefix="fam = fam_t(", suffix=")")
        @:fortax_type_list(fam)
        [famad1, famad2]
    #:endcall
    return fam
    end
#:enddef

@:fortax_fam_gen()
